### 1. 可见性、原子性和有序性问题：多线程BUG的源头
* 源头之一：缓存导致的可见性问题
* 源头之二：线程切换带来的原子性问题
* 源头之三：编译优化带来的有序性问题  
  
### 2. java内存模型：java如何解决可见性和有序性问题
* volatile 关键字，原意指禁用CPU缓存，必须从内存中读或写入
* Happens-Before 规则，前面执行的操作对后面的操作是可见的：  
    1. 程序的顺序性规则，按照程序的顺序，前面代码的操作happens-before于后续的任意操作  
    2. volatile 变量规则，对一个volatile 变量的的写操作 happens-before于后面对于这个变量的读操作
    3. 传递性，如果A happens-before B，且 Bhappens-before C，那么A happens-before C  
    4. 管程中锁的规则，对一个锁的解锁 happens-before 于后续对这个锁的加锁  
    5. 线程的start() 规则，主线程A启动子线程B之后，子线程B能够看到主线程启动B之前的所有操作  
    6. 线程join() 规则，指主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join()方法返回），主线程能够看到子线程的操作   
### 3. 互斥锁上：解决原子性问题  



