# 详解java中的锁
## 一、Lock接口
1. Lock介绍与使用  
> Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。
```java 
// Lock 的用法
Lock lock = new ReentrantLock();
lock.lock();
try {
} finally {
    lock.unlock();
}
```
2. Lock接口提供的synchronized关键字不具备的主要特性  

![Lock接口提供的synchronized关键字不具备的主要特性](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201210163906.png)   

3. Lock是一个接口，它定义了锁获取和释放的基本操作，Lock的API如表所示。

![Lock的API](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201210164210.png)  

##  二、队列同步器
1. 队列同步器介绍
> 队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。 

2. 队列同步器的接口与示例  
同步器可重写的方法
![同步器可重写的方法](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201210165506.png)  
![同步器提供的模板方法](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201210165640.png)  
同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。

3. 队列同步器的实现分析
> 从实现角度分析同步器是如何完成线程同步的，主要包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。

>1. 同步队列
>>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列（基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)），同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。
![同步队列节点属性](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201218144839.png)  
>2. 独占式同步状态的获取与释放  
>> 通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出.
![独占式同步状态的获取流程](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201218145750.png)  
>> 通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）  
>> 总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。

> 3. 共享式同步状态获取与释放  
>> 1. 共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。通过调用同步器的acquireShared(int arg)方法可以共享式地获取同步状态.  
>> 2. 在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。
>> 3. 与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以释放同步状态,该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。

> 4. 独占式超时获取同步状态  
>> 通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。  
![独占式超时获取同步状态的流程](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201218151107.png)

## 三、重入锁
1. 介绍
>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。  
>注意：而synchronized关键字隐式的支持重进入

2. 实现可重入  
> 重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。  
1）线程再次获取锁 。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。  
2）锁的最终释放 。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。  
ReentrantLock是通过组合自定义同步器来实现锁的获取与释放:    
>>再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。  
成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放同步状态时减少同步状态值。  

>ReentrantLock 支持公平锁与非公平锁：
>>公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。

## 四、读写锁  
1. 介绍  
> 读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。

>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。Java并发包提供读写锁的实现是ReentrantReadWriteLock，它提供的特性如表所示。  
![ReentrantReadWriteLock特性](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201218172132.png)

2. 读写所的接口与示例  
>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法，这些方法以及描述如表所示  
![ReentrantReadWriteLock展示内部工作状态的方法](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201218172344.png)  

>示例：通过一个缓存示例说明读写锁的使用方式
```java

```
>读写锁的实现分析:
>> 1. 读写状态的设计  
读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。
如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写，划分方式如图
![读写锁状态的划分方式](https://cdn.jsdelivr.net/gh/xxkasi/image/img/20201218172913.png)  








